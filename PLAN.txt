=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=
CIS 1200 HW07 README
PennKey: 69223261
=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=

============
=: Task 2 :=
============

- Do you plan on creating any new classes in your design? If so, what classes
  are you making, what do they store, and what behaviors do they have?

  I plan on making one new class called Channel.java. I want it to store the 
  channel name, owner ID, user IDs, and privacy status (true or false) for a specific channel.
  The Channel class is able to add and remove a user from the channel, get a copy of the
  set of user IDs currently in the channel, get the ID of the owner of the channel, and get
  the name of the channel (and later also be able to check if the channel is private).

- How do you plan on storing what users are registered on the server?

  The users that are registered on the server are going to be stored in the Channel class.
  I can make a Channel object and call the getIdSet() method which should get me a set of
  all the user's id's that are in that Channel.

- How do you plan on keeping track of which user has which user ID, considering
  the fact that the user's nickname can change over the course of the program?

  I plan on using a userMap variable (which is a TreeMap data structure), and that will keep
  the updated name as the value and the user ID as the key, so even if the nickname is changed,
  the value (id) that is associated with the key will not.

- How do you plan on storing what users are in a channel?

  In the ServerModel, the users within a channel are stored using the idSet field within the
  Channel class, which is a Set<Integer> representing user IDs. The addUser and removeUser
  methods modify this set when users join or leave a channel, and the getUsersInChannel method
  gets a collection of user nicknames by mapping the user IDs from the idSet to their
  respective nicknames in the userMap. 

- How do you plan on keeping track of which user is the owner of each channel?

  In the ServerModel, the owner of each channel is tracked by storing the owner's user
  ID in the ownerId field within the Channel class. This field is set when a new channel
  is created in the createChannel method and is used to retrieve the owner's nickname when
  needed. The getOwner method utilizes this information to return the nickname of the owner
  of a specified channel.

- Justify your choice of collections (Set, Map, or List) for the
  collections you use in your design.

  Using TreeMap for channelMap and userMap in ServerModel is justified since ordered
  key-value pairs are needed based on either channel names or user IDs. TreeMap provides
  an ordering of elements and it is to search (and modify) for both channels and users.
  This choice is particularly beneficial when querying and managing these collections
  based on their respective keys.

============
=: Task 3 :=
============

- Did you make any changes to your design while doing this task? Why?

  I didn't feel like I had to change any part of my design for this Task. The design's
  robustness in handling user-related functionalities is evident in the implementation of
  registerUser, deregisterUser, and changeNickname. The userMap accurately maintains user ID to
  nickname mappings. Also, the consideration of channel notifications and server state updates
  in deregisterUser aligns with the original design's encapsulation. The existing structure,
  (including the validation checks in changeNickname and the use of Broadcast objects),
  made the design unnecessary to change.


============
=: Task 4 :=
============

- Did you make any changes to your design while doing this task? Why?

  I found that I, thankfully, did not have to make any changes to my design  when doing this task.
  Using TreeMap for userMap and channelMap, along with a dedicated Channel class, ensured a
  design model where the map structures provided efficient lookup and management
  of user and channel information. The sorted order simplifies tasks, such as creating and
  joining channels, while the key-values made organized mapping for user and
  channel details. TreeMap's modifiability and navigable operations further enhance the
  implementation of these functionalities by supporting easy update if need be (such as when
  leaving the channel).


============
=: Task 5 :=
============

- How do you plan on keeping track of which channels are invite-only?

  The privacy status of channels is tracked through the isPrivate boolean field in
  the Channel class. During the creation of a new channel in the ServerModel class,
  the boolean value indicating whether the channel is invite-only or not is determined
  through the CreateCommand object's isInviteOnly() method. This information is stored
  in the isPrivate field of the corresponding Channel object, allowing the server to
  distinguish between invite-only and non-invite-only channels.

- Will you make any changes to your work from before in order to make
  implementing invite-only channels easier?

  I will slightly modify the Channel class so that it now contains a method that will
  determine if the Channel is private or not. If it is, then only the owner can add and
  remove a user from the Channel, otherwise it does not matter.


============
=: Task 6 :=
============

- Did you have to make any changes to your design in Task 6? Why?

  No, there were no changes that needed to be made to the design in Task 6. The
  existing implementation was structured efficiently, minimizing redundancy, duplicate
  code, and convoluted functions. The design already prioritized readability and
  maintainability, making it unnecessary to introduce major adjustments or additional helpers.

- If you were to redo this assignment, what changes (if any) would you make in
  how you designed your code?

  If I were to redo this I would write more functions that would handle smaller
  parts of my code. This would make the code and processes more efficient to run.